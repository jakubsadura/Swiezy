// Copyright 2007 Pompeu Fabra University (Computational Imaging Laboratory), Barcelona, Spain. Web: www.cilab.upf.edu.
// This software is distributed WITHOUT ANY WARRANTY; 
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

#ifndef GENERICSEGMENTATIONUTILS_H
#define GENERICSEGMENTATIONUTILS_H

#include "CILabNamespaceMacros.h"
#include "CILabAssertMacros.h"
#include "coreEnvironment.h"
#include "coreKernel.h"
#include "coreDataEntityHelper.h"
#include "coreDataEntityHelper.txx"
#include "coreVTKPolyDataHolder.h"
#include "vtkImageGaussianSmooth.h"
#include "vtkMarchingCubes.h"
#include "vtkCleanPolyData.h"
#include "meRemoveInnerSurfaceFilter.h"
#include "vtkSmoothPolyDataFilter.h"
#include "vtkPolyDataNormals.h"
#include "itkImageToVTKImageFilter.h"

namespace BinImageToMesh{

template< class ItkImageType >
Core::vtkPolyDataPtr  CreateIsoSurface(typename ItkImageType::Pointer image, double isoValue, bool removeInnerSurface)
{
	Core::vtkPolyDataPtr mesh = Core::vtkPolyDataPtr::New();
	GetSurface<ItkImageType>(image, mesh, isoValue, removeInnerSurface);
	return mesh;
}

template< class ItkImageType >
void GetSurface(typename ItkImageType::Pointer image, Core::vtkPolyDataPtr surface, double isoValue, bool removeInnerSurface)
{
	typedef itk::ImageToVTKImageFilter< ItkImageType > ITK2VTKType;
	typename ITK2VTKType::Pointer itk2vtk = ITK2VTKType::New();
	itk2vtk->SetInput( image );
	itk2vtk->Update();

	vtkSmartPointer<vtkImageData> outputImage = vtkSmartPointer<vtkImageData>::New( );
	outputImage->DeepCopy( itk2vtk->GetOutput() );

	//-------------------------------------------------------------------
	//Smooth the Volume Data
	//-------------------------------------------------------------------
	//Some "binary" volume would produce stepped surfaces if we do not blur
	//it. The Gaussian kernel specified accomplishes the smoothing. The amount
	//of smoothing is controlled by the Gaussian standard deviation that is
	//independently specified for each axis of the volume data.
	vtkSmartPointer<vtkImageGaussianSmooth> gaussian = vtkSmartPointer<vtkImageGaussianSmooth>::New();
	gaussian->SetDimensionality( 3 );
	gaussian->SetStandardDeviation( 0.5, 0.5, 0.5 );   //could be set by user
	gaussian->SetRadiusFactor( 0.5 );
	gaussian->SetInput( outputImage );
	gaussian->Update();

	//-------------------------------------------------------------------
	//Generate Triangles
	//-------------------------------------------------------------------
	//The filter runs faster if gradient and normal calculations are turned off.
	vtkSmartPointer<vtkMarchingCubes> mcubes = vtkSmartPointer<vtkMarchingCubes>::New();
	mcubes->SetInput( gaussian->GetOutput() );
	mcubes->ComputeScalarsOff();
	mcubes->ComputeGradientsOff();
	mcubes->ComputeNormalsOff();
	mcubes->SetValue( 0, isoValue );
	mcubes->Update();

	if ( mcubes->GetOutput()->GetNumberOfPolys() == 0) {
		surface->DeepCopy( mcubes->GetOutput() );
		mcubes->Delete();
		return;
	}

	vtkCleanPolyData *cleanMesh = vtkCleanPolyData::New();
	cleanMesh->SetInput(mcubes->GetOutput());
	cleanMesh->ConvertPolysToLinesOff();
	cleanMesh->SetTolerance (1.0e-10);
	cleanMesh->SetAbsoluteTolerance (1.0e-10);
	cleanMesh->Update();

	/*
	//-------------------------------------------------------------------
	//Reduce the Number of Triangles
	//-------------------------------------------------------------------
	//There are often many more triangles generated by the isosurfacing algorithm
	//than it is needed for rendering. 
	vtkSmartPointer<vtkDecimatePro> decimator = vtkSmartPointer<vtkDecimatePro>::New();
	decimator->SetInput( mcubes->GetOutput() );
	//decimator->SetMaximumError( 1 );
	decimator->SetTargetReduction( 0.5 ); //can be set by user
	decimator->PreserveTopologyOn();
	decimator->Update();
	*/

	//-------------------------------------------------------------------
	//Remove inner surface
	//-------------------------------------------------------------------
	vtkSmartPointer< vtkPolyData > smoothInput; 
	if (removeInnerSurface )
	{
		vtkSmartPointer< RemoveInnerSurfaceFilter<ItkImageType> > removeInnerSurfaceFilter = vtkSmartPointer< RemoveInnerSurfaceFilter<ItkImageType> >::New();
		removeInnerSurfaceFilter->SetInput(cleanMesh->GetOutput());
		//	removeInnerSurfaceFilter->SetInput(decimator->GetOutput());
		removeInnerSurfaceFilter->SetInputDistanceMap(image);
		removeInnerSurfaceFilter->Update();
		smoothInput = removeInnerSurfaceFilter->GetOutput();
	}
	else
		smoothInput = cleanMesh->GetOutput();

	//-------------------------------------------------------------------
	//Smooth the Triangle Vertices
	//-------------------------------------------------------------------
	//Laplacian smoothing is used, and triangle vertices are adjusted as
	//an average of neighbouring vertices. Models that are heavily decimated
	//can sometimes be improved with additional polygonal smoothing.
	vtkSmartPointer<vtkSmoothPolyDataFilter> smoother = vtkSmartPointer<vtkSmoothPolyDataFilter>::New();
	smoother->SetInput( smoothInput ); //use output of new filter
	smoother->SetFeatureAngle( 60.0 );
	smoother->SetRelaxationFactor( 0.2 );	// before: 0.2
	smoother->SetNumberOfIterations( 10 ); // before: 5
	smoother->GenerateErrorVectorsOff();
	smoother->FeatureEdgeSmoothingOff();
	smoother->BoundarySmoothingOff();
	smoother->SetConvergence( 0.0 );
	smoother->Update();

	//-------------------------------------------------------------------
	//Generate Normals
	//-------------------------------------------------------------------
	vtkSmartPointer<vtkPolyDataNormals> normals = vtkSmartPointer<vtkPolyDataNormals>::New();
	normals->SetInput( smoother->GetOutput() );
	normals->SplittingOff();	//to avoid duplicate vertices due to sharp edges
	normals->Update();
	surface->DeepCopy( normals->GetOutput() );
}

} // gsp

#endif //GENERICSEGMENTATIONUTILS_H
